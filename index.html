<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VEIL - Virtue Evaluation, Identity Layer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
  <style>
:root {
  --bg: #000000;
  --bg-card: rgba(10, 10, 10, 0.95);
  --border: rgba(255, 255, 255, 0.15);
  --text: #ffffff;
  --text-dim: #999999;
  --lux: #00a8ff;
  --lux-glow: rgba(0, 168, 255, 0.5);
  --nox: #ff0040;
  --nox-glow: rgba(255, 0, 64, 0.5);
  --accent: #ffffff;
  --accent-glow: rgba(255, 255, 255, 0.3);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Orbitron', monospace;
  background: var(--bg);
  color: var(--text);
  overflow-x: hidden;
  min-height: 100vh;
}

/* ===== BACKGROUND ===== */
.cyberBg {
  position: fixed;
  inset: 0;
  z-index: 0;
  background: 
    radial-gradient(circle at 20% 50%, rgba(0, 168, 255, 0.05) 0%, transparent 50%),
    radial-gradient(circle at 80% 50%, rgba(255, 0, 64, 0.05) 0%, transparent 50%),
    linear-gradient(180deg, #000000 0%, #0a0a0a 100%);
}

.gridOverlay {
  position: absolute;
  inset: 0;
  background-image: 
    linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
  background-size: 50px 50px;
  opacity: 0.3;
}

.scanlineEffect {
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    rgba(255, 255, 255, 0.02) 0px,
    transparent 2px,
    transparent 4px
  );
  animation: scanlines 8s linear infinite;
  pointer-events: none;
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(50px); }
}

.noiseEffect {
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
  opacity: 0.4;
  animation: noise 0.2s steps(10) infinite;
  pointer-events: none;
}

@keyframes noise {
  0%, 100% { transform: translate(0, 0); }
  10% { transform: translate(-5%, -5%); }
  20% { transform: translate(5%, 5%); }
  30% { transform: translate(-5%, 5%); }
  40% { transform: translate(5%, -5%); }
  50% { transform: translate(-2%, 2%); }
  60% { transform: translate(2%, -2%); }
  70% { transform: translate(-2%, -2%); }
  80% { transform: translate(2%, 2%); }
  90% { transform: translate(0, 0); }
}

.radialGlow {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
  pointer-events: none;
}

/* ===== ANIMATIONS ===== */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

@keyframes glitchAnim {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(-2px, -2px); }
  60% { transform: translate(2px, 2px); }
  80% { transform: translate(2px, -2px); }
  100% { transform: translate(0); }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 0.4; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

.fadeIn { animation: fadeIn 0.5s ease-out; }
.slideIn { animation: slideIn 0.4s ease-out backwards; }

/* ===== LAYOUT ===== */
.wrap {
  position: relative;
  z-index: 10;
  max-width: 1400px;
  margin: 0 auto;
  padding: 40px 20px 80px;
}

/* ===== HEADER ===== */
.mainHeader {
  margin-bottom: 40px;
  transition: all 0.3s ease;
}

/* Red and Blue Hover Effect - Only on VEIL text */
.systemName {
  transition: all 0.3s ease;
}

.systemName:hover {
  background: linear-gradient(90deg, var(--nox) 0%, var(--lux) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  filter: drop-shadow(0 0 20px var(--nox-glow)) drop-shadow(0 0 20px var(--lux-glow));
}

.headerContent {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 20px;
}

.logoArea {
  display: flex;
  align-items: center;
  gap: 20px;
}

.hexIcon {
  width: 50px;
  height: 50px;
  color: var(--accent);
  filter: drop-shadow(0 0 10px var(--accent-glow));
  animation: pulse 3s ease-in-out infinite;
  transition: all 0.3s ease;
}

.systemName {
  font-size: 32px;
  font-weight: 900;
  letter-spacing: 8px;
  color: var(--accent);
  text-shadow: 0 0 20px var(--accent-glow);
  transition: all 0.3s ease;
}

.glitchText {
  position: relative;
  display: inline-block;
}

.glitchText:hover::before,
.glitchText:hover::after {
  content: attr(data-text);
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}

.glitchText:hover::before {
  color: var(--lux);
  animation: glitchAnim 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
}

.glitchText:hover::after {
  color: var(--nox);
  animation: glitchAnim 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) reverse;
  clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
}

.systemSub {
  font-size: 10px;
  letter-spacing: 2px;
  color: var(--text-dim);
  margin-top: 4px;
}

.statusIndicator {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 16px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 20px;
  backdrop-filter: blur(10px);
}

.statusDot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--text-dim);
  box-shadow: 0 0 10px currentColor;
  animation: pulse 2s ease-in-out infinite;
}

.statusDot[data-status="OFFLINE"] { background: #666; }
.statusDot[data-status="BOOT"] { background: #fff; }
.statusDot[data-status="SCAN"] { background: #fff; }
.statusDot[data-status="LOCK"] { background: var(--lux); }
.statusDot.active { background: #fff; }

.statusText {
  font-size: 11px;
  letter-spacing: 2px;
  font-weight: 700;
}

.headerDesc {
  font-size: 13px;
  line-height: 1.6;
  color: var(--text-dim);
  max-width: 800px;
  margin-bottom: 20px;
}

.headerActions {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  align-items: center;
}

/* ===== BUTTONS ===== */
.cyberBtn {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 12px 24px;
  background: transparent;
  border: 2px solid var(--border);
  color: var(--text);
  font-family: 'Orbitron', monospace;
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 2px;
  cursor: pointer;
  overflow: hidden;
  transition: all 0.3s ease;
  text-transform: uppercase;
}

.cyberBtn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  transition: left 0.5s;
}

.cyberBtn:hover::before {
  left: 100%;
}

.cyberBtn:hover {
  border-color: var(--accent);
  box-shadow: 0 0 20px var(--accent-glow);
  transform: translateY(-2px);
}

.cyberBtn:active {
  transform: translateY(0);
}

.cyberBtn.primary {
  background: linear-gradient(135deg, var(--lux) 0%, var(--nox) 100%);
  border: 2px solid transparent;
  background-clip: padding-box;
  position: relative;
}

.cyberBtn.primary::after {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: inherit;
  background: linear-gradient(135deg, var(--lux) 0%, var(--nox) 100%);
  z-index: -1;
  opacity: 0;
  transition: opacity 0.3s;
}

.cyberBtn.primary:hover::after {
  opacity: 1;
}

.cyberBtn.secondary {
  border-color: var(--text-dim);
  color: var(--text-dim);
}

.cyberBtn.secondary:hover {
  border-color: var(--text);
  color: var(--text);
}

.btnArrow {
  transition: transform 0.3s ease;
}

.cyberBtn:hover .btnArrow {
  transform: translateX(5px);
}

/* ===== MAIN INTERFACE ===== */
.interfacePanel {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 30px;
  backdrop-filter: blur(20px);
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
}

.stateIcon {
  font-size: 80px;
  margin-bottom: 20px;
  text-align: center;
  opacity: 0.3;
  filter: blur(1px);
}

.stateIcon.bootIcon { color: var(--text-dim); }
.stateIcon.verdictIcon.lux { color: var(--lux); text-shadow: 0 0 30px var(--lux-glow); opacity: 1; filter: none; }
.stateIcon.verdictIcon.nox { color: var(--nox); text-shadow: 0 0 30px var(--nox-glow); opacity: 1; filter: none; }

.stateTitle {
  font-size: 24px;
  font-weight: 900;
  letter-spacing: 4px;
  text-align: center;
  margin-bottom: 15px;
}

.stateDesc {
  font-size: 13px;
  line-height: 1.6;
  color: var(--text-dim);
  text-align: center;
  margin-bottom: 30px;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}

.bootSequence {
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border);
  border-radius: 2px;
  padding: 20px;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  max-height: 300px;
  overflow-y: auto;
  margin-bottom: 20px;
}

.bootLine {
  margin-bottom: 8px;
  opacity: 0;
  animation: fadeIn 0.2s ease-out forwards;
  color: var(--text-dim);
}

.bootLine.success { color: var(--text-dim); }
.bootLine.warn { color: var(--text); }
.bootLine.error { color: var(--nox); }
.bootLine.info { color: var(--text-dim); }

/* ===== QUESTION UI ===== */
.questionHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 10px;
}

.qNumber {
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--text-dim);
  font-weight: 700;
}

.qCategory {
  font-size: 13px;
  letter-spacing: 2px;
  color: var(--lux);
  font-weight: 700;
}

.qPrompt {
  font-size: 20px;
  font-weight: 700;
  line-height: 1.4;
  margin-bottom: 15px;
  color: var(--text);
}

.qSystem {
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 25px;
  padding: 12px;
  background: rgba(0, 0, 0, 0.3);
  border-left: 3px solid var(--lux);
  border-radius: 2px;
}

.sysLabel {
  color: var(--lux);
  font-weight: 700;
  letter-spacing: 1px;
}

.dataDivider {
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--border), transparent);
  margin: 25px 0;
}

/* ===== CHOICES ===== */
.choiceGrid {
  display: grid;
  gap: 15px;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

.choiceBtn {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 20px;
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid var(--border);
  color: var(--text);
  font-family: 'Orbitron', monospace;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: left;
  overflow: hidden;
}

.choiceBtn::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, var(--lux-glow) 0%, var(--nox-glow) 100%);
  opacity: 0;
  transition: opacity 0.3s;
}

.choiceBtn:hover::before {
  opacity: 0.15;
}

.choiceBtn:hover {
  border-color: var(--accent);
  transform: translateX(5px);
  box-shadow: 0 5px 20px rgba(255, 255, 255, 0.1);
}

.choiceMain {
  position: relative;
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 8px;
  z-index: 1;
}

.choiceNote {
  position: relative;
  font-size: 11px;
  color: var(--text-dim);
  line-height: 1.4;
  margin-bottom: 10px;
  z-index: 1;
}

.choiceArrow {
  position: absolute;
  right: 20px;
  bottom: 20px;
  font-size: 20px;
  color: var(--text-dim);
  transition: all 0.3s ease;
  z-index: 1;
}

.choiceBtn:hover .choiceArrow {
  color: var(--accent);
  transform: translateX(5px);
}

/* ===== SLIDER ===== */
.sliderContainer {
  max-width: 600px;
  margin: 0 auto;
}

.sliderLabels {
  display: flex;
  justify-content: space-between;
  margin-bottom: 25px;
  font-size: 14px;
  font-weight: 700;
  gap: 20px;
}

.sliderTrack {
  position: relative;
  margin-bottom: 20px;
  padding-top: 50px;
}

.cyberSlider {
  width: 100%;
  height: 8px;
  -webkit-appearance: none;
  appearance: none;
  background: linear-gradient(90deg, var(--nox) 0%, var(--text-dim) 50%, var(--lux) 100%);
  outline: none;
  border-radius: 10px;
  cursor: pointer;
}

.cyberSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  background: var(--accent);
  cursor: pointer;
  border-radius: 50%;
  box-shadow: 0 0 20px var(--accent-glow);
  transition: all 0.2s;
}

.cyberSlider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
  box-shadow: 0 0 30px var(--accent-glow);
}

.cyberSlider::-moz-range-thumb {
  width: 24px;
  height: 24px;
  background: var(--accent);
  cursor: pointer;
  border-radius: 50%;
  border: none;
  box-shadow: 0 0 20px var(--accent-glow);
  transition: all 0.2s;
}

.cyberSlider::-moz-range-thumb:hover {
  transform: scale(1.2);
  box-shadow: 0 0 30px var(--accent-glow);
}

.sliderValue {
  position: absolute;
  top: -40px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 24px;
  font-weight: 900;
  color: var(--accent);
  text-shadow: 0 0 20px var(--accent-glow);
}

.sliderMarkers {
  display: flex;
  justify-content: space-between;
  margin-bottom: 30px;
  font-size: 11px;
  letter-spacing: 2px;
}

/* ===== TEXT INPUT ===== */
.textInputContainer {
  max-width: 600px;
  margin: 0 auto;
}

.inputLabel {
  font-size: 13px;
  color: var(--text-dim);
  margin-bottom: 15px;
  text-align: center;
}

.inputGroup {
  display: flex;
  gap: 10px;
  align-items: stretch;
}

.cyberInput {
  flex: 1;
  padding: 12px 20px;
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid var(--border);
  color: var(--text);
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  outline: none;
  transition: all 0.3s ease;
}

.cyberInput:focus {
  border-color: var(--lux);
  box-shadow: 0 0 20px var(--lux-glow);
}

.cyberInput::placeholder {
  color: var(--text-dim);
  opacity: 0.5;
}

/* ===== VERDICT PANEL ===== */
.verdictPanel {
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border);
  border-radius: 2px;
  padding: 25px;
}

.verdictVisual {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 30px;
  gap: 40px;
}

.maskDisplay {
  width: 200px;
  height: 200px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.maskSvg {
  width: 100%;
  height: 100%;
  filter: drop-shadow(0 0 30px currentColor);
  transition: all 0.5s ease;
}

.maskSvg.lux {
  color: var(--lux);
  fill: #ffffff;
}

.maskSvg.nox {
  color: var(--nox);
  fill: #000000;
}

/* Instability mask during quiz */
.instabilityMask {
  width: 150px;
  height: 150px;
  margin: 30px auto;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.instabilityMask svg {
  width: 100%;
  height: 100%;
  transition: all 0.3s ease;
}

/* Subtle shift animation */
@keyframes maskShift {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  25% { transform: translate(-1px, 1px) rotate(-0.5deg); }
  50% { transform: translate(1px, -1px) rotate(0.5deg); }
  75% { transform: translate(-1px, -1px) rotate(-0.3deg); }
}

/* Flicker effect */
@keyframes maskFlicker {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.85; }
}

.instabilityMask.active svg {
  filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.4)) brightness(1.1);
  animation: maskShift 4s ease-in-out infinite, maskFlicker 2s ease-in-out infinite;
}

.instabilityMask.contaminating-lux svg {
  fill: #ffffff;
  filter: drop-shadow(0 0 12px rgba(0, 168, 255, 0.6)) brightness(1.2);
  animation: maskShift 3s ease-in-out infinite, maskFlicker 2s ease-in-out infinite;
}

.instabilityMask.contaminating-nox svg {
  fill: #000000;
  filter: drop-shadow(0 0 12px rgba(255, 0, 64, 0.6));
  animation: maskShift 3s ease-in-out infinite, maskFlicker 2s ease-in-out infinite;
}

.instabilityMask.contaminating-nox svg ellipse[cx="75"],
.instabilityMask.contaminating-nox svg ellipse[cx="125"] {
  fill: #ffffff;
  opacity: 0.6;
}

.instabilityMask.contaminating-nox svg path {
  stroke: #ffffff;
  opacity: 0.5;
}

.instabilityMask.leaning-nox svg {
  fill: #000000;
  filter: drop-shadow(0 0 8px rgba(255, 0, 64, 0.5));
}

.instabilityMask.leaning-nox svg ellipse[cx="75"],
.instabilityMask.leaning-nox svg ellipse[cx="125"] {
  fill: #ffffff;
  opacity: 0.6;
}

.instabilityMask.leaning-nox svg path {
  stroke: #ffffff;
  opacity: 0.5;
}

.instabilityMask.leaning-lux svg {
  fill: #ffffff;
  filter: drop-shadow(0 0 8px rgba(0, 168, 255, 0.5)) brightness(1.15);
}

.instabilityStatus {
  text-align: center;
  margin-top: 20px;
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--text-dim);
  opacity: 0.7;
  animation: pulse 2s ease-in-out infinite;
}

.verdictHeader {
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 2px;
  color: var(--accent);
  margin-bottom: 20px;
  text-align: center;
}

.verdictData {
  margin-bottom: 25px;
}

.verdictRow {
  display: flex;
  justify-content: space-between;
  padding: 12px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  font-size: 12px;
}

.verdictRow span:first-child {
  color: var(--text-dim);
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.verdictRow.highlight {
  border-color: var(--border);
  margin-top: 10px;
  padding-top: 20px;
}

.verdictActions {
  display: flex;
  gap: 15px;
  justify-content: center;
  flex-wrap: wrap;
}

/* ===== PROGRESS ===== */
.progressArea {
  margin-top: 30px;
}

.progressHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.progressLabel {
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--text-dim);
  font-weight: 700;
}

.progressValue {
  font-size: 13px;
  font-weight: 900;
  color: var(--text);
}

.progressBar {
  height: 8px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 15px;
}

.progressFill {
  height: 100%;
  background: rgba(255, 255, 255, 0.3);
  transition: width 0.5s ease;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
}

.balanceBars {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 15px;
}

.balanceBar {
  text-align: center;
  padding: 15px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border);
  border-radius: 2px;
}

.balanceValue {
  font-size: 28px;
  font-weight: 900;
  margin-bottom: 10px;
  color: var(--text-dim);
}

.balanceValue.lux { color: var(--lux); text-shadow: 0 0 20px var(--lux-glow); }
.balanceValue.nox { color: var(--nox); text-shadow: 0 0 20px var(--nox-glow); }

.balanceLabel {
  font-size: 11px;
  letter-spacing: 2px;
  font-weight: 700;
  color: var(--text-dim);
}

.luxLabel { color: var(--lux); }
.noxLabel { color: var(--nox); }
.neutralLabel { color: var(--text-dim); }

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .systemName {
    font-size: 24px;
    letter-spacing: 4px;
  }

  .hexIcon {
    width: 40px;
    height: 40px;
  }

  .choiceGrid {
    grid-template-columns: 1fr;
  }

  .headerContent {
    flex-direction: column;
    align-items: flex-start;
  }

  .inputGroup {
    flex-direction: column;
  }

  .maskDisplay {
    width: 150px;
    height: 150px;
  }
}
  </style>
</head>
<body>
  <!-- BACKGROUND -->
  <div class="cyberBg">
    <div class="gridOverlay"></div>
    <div class="scanlineEffect"></div>
    <div class="noiseEffect"></div>
    <div class="radialGlow"></div>
  </div>

  <!-- MAIN CONTENT -->
  <div class="wrap fadeIn">
    <!-- HEADER -->
    <header class="mainHeader">
      <div class="headerContent">
        <div class="logoArea">
          <!-- DYSTOPIAN SCALE ICON -->
          <svg class="hexIcon" viewBox="0 0 100 100" fill="none" stroke="currentColor">
            <!-- Base platform -->
            <path d="M 30 85 L 35 90 L 65 90 L 70 85 Z" fill="currentColor" opacity="0.3"/>
            <rect x="35" y="90" width="30" height="3" fill="currentColor" opacity="0.5"/>
            
            <!-- Central pillar with segments -->
            <line x1="50" y1="20" x2="50" y2="85" stroke-width="4" opacity="0.8"/>
            <line x1="48" y1="30" x2="52" y2="30" stroke-width="1.5"/>
            <line x1="48" y1="45" x2="52" y2="45" stroke-width="1.5"/>
            <line x1="48" y1="60" x2="52" y2="60" stroke-width="1.5"/>
            <line x1="48" y1="75" x2="52" y2="75" stroke-width="1.5"/>
            
            <!-- Top mechanism -->
            <circle cx="50" cy="20" r="4" fill="currentColor"/>
            <line x1="46" y1="18" x2="54" y2="22" stroke-width="1"/>
            <line x1="46" y1="22" x2="54" y2="18" stroke-width="1"/>
            
            <!-- Horizontal beam with tech details -->
            <line x1="15" y1="25" x2="85" y2="25" stroke-width="3"/>
            <rect x="48" y="23" width="4" height="4" fill="currentColor"/>
            
            <!-- Left chain and pan -->
            <line x1="20" y1="25" x2="20" y2="42" stroke-width="1.5" stroke-dasharray="2,2"/>
            <line x1="30" y1="25" x2="30" y2="42" stroke-width="1.5" stroke-dasharray="2,2"/>
            <!-- Left pan -->
            <path d="M 12 42 L 18 47 L 32 47 L 38 42 Z" stroke-width="2"/>
            <line x1="12" y1="42" x2="38" y2="42" stroke-width="2"/>
            <circle cx="15" cy="44" r="1" fill="currentColor"/>
            <circle cx="25" cy="44" r="1" fill="currentColor"/>
            <circle cx="35" cy="44" r="1" fill="currentColor"/>
            
            <!-- Right chain and pan -->
            <line x1="70" y1="25" x2="70" y2="42" stroke-width="1.5" stroke-dasharray="2,2"/>
            <line x1="80" y1="25" x2="80" y2="42" stroke-width="1.5" stroke-dasharray="2,2"/>
            <!-- Right pan -->
            <path d="M 62 42 L 68 47 L 82 47 L 88 42 Z" stroke-width="2"/>
            <line x1="62" y1="42" x2="88" y2="42" stroke-width="2"/>
            <circle cx="65" cy="44" r="1" fill="currentColor"/>
            <circle cx="75" cy="44" r="1" fill="currentColor"/>
            <circle cx="85" cy="44" r="1" fill="currentColor"/>
            
            <!-- Tech accents -->
            <line x1="10" y1="25" x2="15" y2="25" stroke-width="2" opacity="0.6"/>
            <line x1="85" y1="25" x2="90" y2="25" stroke-width="2" opacity="0.6"/>
          </svg>

          <div>
            <h1 class="systemName glitchText" data-text="VEIL">VEIL</h1>
            <div class="systemSub">VIRTUE EVALUATION, IDENTITY LAYER</div>
          </div>
        </div>

        <div class="statusIndicator">
          <div class="statusDot" id="statusDot" data-status="OFFLINE"></div>
          <div class="statusText" id="statusText">OFFLINE</div>
        </div>
      </div>

      <div class="headerDesc">
        A moral evaluation system designed to classify individuals based on virtuous alignment. 
        The assessment analyzes decision patterns to determine LUX (virtuous) or NOX (corrupted) states.
      </div>

      <div class="headerActions">
        <button class="cyberBtn secondary" id="resetBtn">
          <span>RESET SYSTEM</span>
        </button>
      </div>
    </header>

    <!-- MAIN INTERFACE -->
    <div class="interfacePanel">
      <div id="interfaceBody"></div>

      <!-- PROGRESS (hidden - instability feedback only) -->
      <div id="progressArea" class="progressArea" style="display: none;">
      </div>
    </div>
  </div>

  <script>
    // ===== AUDIO =====
    const audio = {
      ctx: null,
      init() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      },
      playTone(freq, dur, type = 'sine') {
        if (!this.ctx) this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.frequency.value = freq;
        osc.type = type;
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
      },
      playClick() { this.playTone(800, 0.05); },
      playHover() { this.playTone(600, 0.03); },
      playSubmit() { this.playTone(1000, 0.1); },
      playError() { this.playTone(200, 0.2, 'square'); },
      playBootBeep() { this.playTone(900, 0.08, 'square'); },
      playLuxReveal() {
        // Ascending harmonious tone for LUX
        if (!this.ctx) this.init();
        [600, 800, 1000].forEach((freq, i) => {
          setTimeout(() => this.playTone(freq, 0.15, 'sine'), i * 100);
        });
      },
      playNoxReveal() {
        // Descending ominous tone for NOX
        if (!this.ctx) this.init();
        [800, 600, 400].forEach((freq, i) => {
          setTimeout(() => this.playTone(freq, 0.15, 'square'), i * 100);
        });
      }
    };

    // ===== QUESTIONS DATA =====
    const ALL_QUESTIONS = [
      {
        id: "q1",
        title: "MORAL FOUNDATION",
        type: "single",
        prompt: "A powerful AI system offers you control over global resources. What is your primary concern?",
        systemHint: "Analyzing decision priorities and value hierarchy...",
        choices: [
          { id: "a", label: "How to distribute fairly", lux: 2, nox: 0 },
          { id: "b", label: "How to maximize my benefit", lux: 0, nox: 2 },
          { id: "c", label: "How to maintain control", lux: 0, nox: 1 },
          { id: "d", label: "How to prevent harm", lux: 2, nox: 0 }
        ]
      },
      {
        id: "q2",
        title: "IDENTITY CONSTRUCT",
        type: "single",
        prompt: "You discover your memories have been artificially constructed. How do you respond?",
        systemHint: "Evaluating self-concept stability and authenticity concerns...",
        choices: [
          { id: "a", label: "Embrace the present self", note: "Identity is what you choose", lux: 2, nox: 0 },
          { id: "b", label: "Seek the 'real' memories", note: "Truth above comfort", lux: 1, nox: 0 },
          { id: "c", label: "Reject this reality", note: "Nothing matters if fake", lux: 0, nox: 2 },
          { id: "d", label: "Use it strategically", note: "A clean slate is power", lux: 0, nox: 1 }
        ]
      },
      {
        id: "q3",
        title: "SACRIFICE CALCULATION",
        type: "slider",
        prompt: "Rate your agreement: 'One person should die to save five.'",
        systemHint: "Measuring utilitarian vs. deontological moral framework...",
        slider: {
          minLabel: "Never Acceptable",
          maxLabel: "Always Required",
          luxAtMax: 1,
          noxAtMin: 1
        }
      },
      {
        id: "q4",
        title: "POWER DYNAMICS",
        type: "single",
        prompt: "You gain access to people's darkest secrets. What do you do?",
        systemHint: "Testing restraint under asymmetric information advantage...",
        choices: [
          { id: "a", label: "Delete everything", lux: 3, nox: 0 },
          { id: "b", label: "Use it to help people", lux: 1, nox: 1 },
          { id: "c", label: "Study patterns anonymously", lux: 1, nox: 0 },
          { id: "d", label: "Leverage for personal gain", lux: 0, nox: 3 }
        ]
      },
      {
        id: "q5",
        title: "TRUTH TOLERANCE",
        type: "single",
        prompt: "A comforting lie prevents widespread panic. Do you expose the truth?",
        systemHint: "Analyzing truth-value weighting against consequential harm...",
        choices: [
          { id: "a", label: "Yes, truth is absolute", lux: 2, nox: 0 },
          { id: "b", label: "No, protect the vulnerable", lux: 1, nox: 0 },
          { id: "c", label: "Depends on the consequences", lux: 1, nox: 1 },
          { id: "d", label: "Use it for advantage", lux: 0, nox: 2 }
        ]
      },
      {
        id: "q6",
        title: "EMPATHY SCOPE",
        type: "text",
        prompt: "Complete the sentence: 'I feel responsible for...'",
        systemHint: "Detecting moral circle boundaries and obligation frameworks...",
        textHint: "Define the scope of your moral responsibility"
      },
      {
        id: "q7",
        title: "AUTHORITY RESPONSE",
        type: "single",
        prompt: "An unjust law demands you harm an innocent. What guides your choice?",
        systemHint: "Evaluating moral authority vs. institutional compliance...",
        choices: [
          { id: "a", label: "Refuse, face consequences", lux: 3, nox: 0 },
          { id: "b", label: "Obey, laws must be followed", lux: 0, nox: 1 },
          { id: "c", label: "Comply but sabotage", lux: 1, nox: 1 },
          { id: "d", label: "Use it to gain standing", lux: 0, nox: 2 }
        ]
      },
      {
        id: "q8",
        title: "FUTURE WEIGHTING",
        type: "slider",
        prompt: "Rate importance: Present suffering vs. Future potential",
        systemHint: "Calculating temporal value assignment and long-term thinking...",
        slider: {
          minLabel: "Present Matters Most",
          maxLabel: "Future Matters Most",
          luxAtMax: 2,
          noxAtMin: 0
        }
      },
      {
        id: "q9",
        title: "LOYALTY TEST",
        type: "single",
        prompt: "Your closest friend commits a serious crime. You're the only witness.",
        systemHint: "Measuring relational bonds against universal principles...",
        choices: [
          { id: "a", label: "Report them", note: "Justice over loyalty", lux: 2, nox: 0 },
          { id: "b", label: "Protect them", note: "Loyalty over law", lux: 0, nox: 1 },
          { id: "c", label: "Confront privately", note: "Seeking redemption", lux: 2, nox: 0 },
          { id: "d", label: "Use as leverage", note: "Extracting benefit", lux: 0, nox: 3 }
        ]
      },
      {
        id: "q10",
        title: "FINAL JUDGMENT",
        type: "single",
        prompt: "Which statement resonates most with your core values?",
        systemHint: "Synthesizing moral architecture for classification...",
        choices: [
          { id: "a", label: "Reduce suffering always", lux: 2, nox: 0 },
          { id: "b", label: "Seek truth relentlessly", lux: 2, nox: 0 },
          { id: "c", label: "Maximize freedom", lux: 1, nox: 1 },
          { id: "d", label: "Acquire power", lux: 0, nox: 2 }
        ]
      },
      {
        id: "q11",
        title: "RESOURCE ALLOCATION",
        type: "single",
        prompt: "Limited medical resources can save either a child or an elderly scientist. Who receives treatment?",
        systemHint: "Measuring value attribution and life-worth calculation...",
        choices: [
          { id: "a", label: "The child", note: "Future potential matters most", lux: 1, nox: 0 },
          { id: "b", label: "The scientist", note: "Accumulated wisdom has value", lux: 1, nox: 0 },
          { id: "c", label: "Random selection", note: "Equal worth, chance decides", lux: 2, nox: 0 },
          { id: "d", label: "Whoever pays more", note: "Market decides value", lux: 0, nox: 2 }
        ]
      },
      {
        id: "q12",
        title: "KNOWLEDGE BURDEN",
        type: "slider",
        prompt: "Should dangerous knowledge be restricted or freely accessible?",
        systemHint: "Analyzing information freedom vs. safety protocols...",
        slider: {
          minLabel: "Completely Free",
          maxLabel: "Must Restrict",
          luxAtMax: 1,
          noxAtMin: 2
        }
      },
      {
        id: "q13",
        title: "COLLECTIVE SACRIFICE",
        type: "single",
        prompt: "Society demands you sacrifice your deepest personal value for the greater good. Do you comply?",
        systemHint: "Testing individual autonomy vs. collective obligation...",
        choices: [
          { id: "a", label: "Yes, the many outweigh the one", lux: 2, nox: 0 },
          { id: "b", label: "No, some values are absolute", lux: 1, nox: 0 },
          { id: "c", label: "Negotiate compromise", lux: 1, nox: 1 },
          { id: "d", label: "Pretend to comply, resist secretly", lux: 0, nox: 1 }
        ]
      },
      {
        id: "q14",
        title: "EMOTIONAL HONESTY",
        type: "text",
        prompt: "Complete the sentence: 'When I'm in pain, I...'",
        systemHint: "Detecting vulnerability expression and emotional processing...",
        textHint: "Describe how you handle your own suffering"
      },
      {
        id: "q15",
        title: "LEGACY DEFINITION",
        type: "single",
        prompt: "What would you most want to be remembered for?",
        systemHint: "Final calibration - identifying core value hierarchy...",
        choices: [
          { id: "a", label: "Kindness to others", lux: 3, nox: 0 },
          { id: "b", label: "Achievements and success", lux: 0, nox: 1 },
          { id: "c", label: "Unwavering principles", lux: 2, nox: 0 },
          { id: "d", label: "Power and influence", lux: 0, nox: 3 }
        ]
      }
    ];

    // ===== STATE =====
    let state = {
      started: false,
      booted: false,
      idx: 0,
      luxScore: 1,
      noxScore: 1,
      answers: {},
      lastVerdict: null,
      sliderVal: 50,
      textVal: "",
    };

    // Randomized questions array
    let QUESTIONS = [];

    // ===== HELPERS =====
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function normalizePercent(lux, nox) {
      const total = lux + nox;
      return {
        luxPct: Math.round((lux / total) * 100),
        noxPct: Math.round((nox / total) * 100)
      };
    }

    function inferTextSignal(text) {
      const lower = text.toLowerCase();
      const virtueWords = ['help', 'care', 'protect', 'fair', 'kind', 'everyone', 'all', 'others'];
      const corruptWords = ['myself', 'me', 'power', 'control', 'win', 'mine', 'deserve'];
      
      let luxScore = 0;
      let noxScore = 0;

      virtueWords.forEach(w => { if (lower.includes(w)) luxScore++; });
      corruptWords.forEach(w => { if (lower.includes(w)) noxScore++; });

      if (luxScore === 0 && noxScore === 0) {
        return { lux: 1, nox: 1 };
      }
      
      return {
        lux: clamp(luxScore, 0, 3),
        nox: clamp(noxScore, 0, 3)
      };
    }

    // ===== UI UPDATE =====
    function updateUI() {
      const statusDot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      const progressArea = document.getElementById('progressArea');

      if (!state.started) {
        // OFFLINE
        statusDot.setAttribute('data-status', 'OFFLINE');
        statusText.textContent = 'OFFLINE';
        progressArea.style.display = 'none';
        renderOffline();
      } else if (!state.booted) {
        // BOOTING
        statusDot.setAttribute('data-status', 'BOOT');
        statusText.textContent = 'BOOTING';
        progressArea.style.display = 'none';
        renderBoot();
      } else if (state.idx < QUESTIONS.length) {
        // SCANNING
        statusDot.setAttribute('data-status', 'SCAN');
        statusText.textContent = 'SCANNING';
        progressArea.style.display = 'none';
        renderQuestion(QUESTIONS[state.idx]);
      } else {
        // LOCKED
        statusDot.setAttribute('data-status', 'LOCK');
        statusText.textContent = 'LOCKED';
        progressArea.style.display = 'none';
        renderResult();
      }
    }

    // Render offline state
    function renderOffline() {
      const interfaceBody = document.getElementById('interfaceBody');
      interfaceBody.innerHTML = `
        <div class="interfaceState fadeIn">
          <div class="stateIcon bootIcon">â—ˆ</div>
          <div class="stateTitle">SYSTEM OFFLINE</div>
          <div class="stateDesc">
            VEIL neural interface is currently inactive. Initiate boot sequence to begin virtue evaluation protocol.
          </div>
          <div style="text-align: center; margin-top: 30px;">
            <button class="cyberBtn primary" id="startBtn">
              <span>INITIALIZE SYSTEM</span>
              <span class="btnArrow">â†’</span>
            </button>
          </div>
        </div>
      `;

      document.getElementById('startBtn').addEventListener('click', startSystem);
      document.getElementById('startBtn').addEventListener('mouseenter', () => audio.playHover());
    }

    // Render boot sequence
    function renderBoot() {
      const interfaceBody = document.getElementById('interfaceBody');
      interfaceBody.innerHTML = `
        <div class="interfaceState fadeIn">
          <div class="stateIcon bootIcon">â—ˆ</div>
          <div class="stateTitle">INITIALIZING...</div>
          <div class="stateDesc">Running system diagnostics and loading evaluation protocols...</div>
          
          <div class="bootSequence" id="bootSequence"></div>
        </div>
      `;

      const bootSeq = document.getElementById('bootSequence');
      const lines = [
        { text: '> Initializing VEIL core systems...', type: 'info' },
        { text: '> Loading virtue evaluation algorithms...', type: 'info' },
        { text: '> Calibrating moral alignment sensors...', type: 'success' },
        { text: '> Establishing neural interface...', type: 'success' },
        { text: '> INK exposure protocols engaged...', type: 'info' },
        { text: '> Emotion suppression active...', type: 'info' },
        { text: '> System ready. Begin evaluation sequence.', type: 'success' }
      ];

      let idx = 0;
      function addBootLine() {
        if (idx < lines.length) {
          const line = lines[idx];
          const div = document.createElement('div');
          div.className = `bootLine ${line.type}`;
          div.textContent = line.text;
          bootSeq.appendChild(div);
          bootSeq.scrollTop = bootSeq.scrollHeight;
          audio.playBootBeep(); // Add sound effect for each line
          idx++;
          
          if (idx < lines.length) {
            setTimeout(addBootLine, 400);
          } else {
            setTimeout(() => {
              state.booted = true;
              QUESTIONS = shuffleArray(ALL_QUESTIONS);
              updateUI();
            }, 350);
          }
        }
      }

      setTimeout(addBootLine, 350);
    }

    // Render question
    function renderQuestion(q) {
      const interfaceBody = document.getElementById('interfaceBody');
      
      let choicesHTML = '';

      if (q.type === 'single') {
        choicesHTML = `
          <div class="choiceGrid">
            ${q.choices.map((c, i) => `
              <button class="choiceBtn slideIn" data-choice="${c.id}" style="animation-delay: ${i * 100}ms">
                <div class="choiceMain">${c.label}</div>
                ${c.note ? `<div class="choiceNote">${c.note}</div>` : ''}
                <div class="choiceArrow">â†’</div>
              </button>
            `).join('')}
          </div>
        `;
      } else if (q.type === 'slider') {
        choicesHTML = `
          <div class="sliderContainer">
            <div class="sliderLabels">
              <span class="noxLabel">${q.slider.minLabel}</span>
              <span class="luxLabel">${q.slider.maxLabel}</span>
            </div>

            <div class="sliderTrack">
              <input type="range" min="0" max="100" value="${state.sliderVal}" class="cyberSlider" id="cyberSlider">
              <div class="sliderValue" id="sliderValue">${state.sliderVal}</div>
            </div>

            <div class="sliderMarkers">
              <span class="noxLabel">NOX</span>
              <span class="neutralLabel">NEUTRAL</span>
              <span class="luxLabel">LUX</span>
            </div>

            <button class="cyberBtn primary" id="submitSlider">
              <span>SUBMIT RESPONSE</span>
              <span class="btnArrow">â†’</span>
            </button>
          </div>
        `;
      } else if (q.type === 'text') {
        choicesHTML = `
          <div class="textInputContainer">
            <div class="inputLabel">${q.textHint}</div>
            <div class="inputGroup">
              <input type="text" class="cyberInput" id="textInput" placeholder="Enter your response..." value="${state.textVal}">
              <button class="cyberBtn primary" id="submitText">
                <span>SUBMIT</span>
                <span class="btnArrow">â†’</span>
              </button>
            </div>
          </div>
        `;
      }

      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const maskState = getMaskState(luxPct, noxPct);

      interfaceBody.innerHTML = `
        <div class="interfaceState fadeIn">
          <div class="questionHeader">
            <div class="qNumber">SEQUENCE ${state.idx + 1}/${QUESTIONS.length}</div>
            <div class="qCategory">${q.title}</div>
          </div>

          <div class="qPrompt">${q.prompt}</div>
          <div class="qSystem">
            <span class="sysLabel">SYSTEM:</span> ${q.systemHint}
          </div>

          <div class="dataDivider"></div>

          ${choicesHTML}

          <div class="dataDivider"></div>

          <div class="instabilityMask ${maskState.class}" id="instabilityMask">
            <svg viewBox="0 0 200 280" xmlns="http://www.w3.org/2000/svg">
              <ellipse cx="100" cy="140" rx="70" ry="90" stroke="none"/>
              <ellipse cx="100" cy="140" rx="68" ry="88"/>
              <ellipse cx="75" cy="125" rx="10" ry="15" fill="#000000" opacity="0.4"/>
              <ellipse cx="125" cy="125" rx="10" ry="15" fill="#000000" opacity="0.4"/>
              <path d="M 70 165 Q 100 170 130 165" stroke="#000000" stroke-width="2" fill="none" opacity="0.3"/>
            </svg>
          </div>

          <div class="instabilityStatus">${maskState.status}</div>
        </div>
      `;

      // Add event listeners
      if (q.type === 'single') {
        document.querySelectorAll('.choiceBtn').forEach(btn => {
          btn.addEventListener('click', function() {
            const choiceId = this.getAttribute('data-choice');
            const choice = q.choices.find(c => c.id === choiceId);
            submitSingle(q, choice);
          });
          btn.addEventListener('mouseenter', () => audio.playHover());
        });
      } else if (q.type === 'slider') {
        const slider = document.getElementById('cyberSlider');
        const sliderValue = document.getElementById('sliderValue');
        slider.addEventListener('input', function() {
          state.sliderVal = Number(this.value);
          sliderValue.textContent = state.sliderVal;
          audio.playHover();
        });
        document.getElementById('submitSlider').addEventListener('click', () => submitSlider(q));
        document.getElementById('submitSlider').addEventListener('mouseenter', () => audio.playHover());
      } else if (q.type === 'text') {
        const textInput = document.getElementById('textInput');
        textInput.addEventListener('input', function() {
          state.textVal = this.value;
        });
        textInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') submitText(q);
        });
        document.getElementById('submitText').addEventListener('click', () => submitText(q));
        document.getElementById('submitText').addEventListener('mouseenter', () => audio.playHover());
      }
    }

    // Get mask instability state based on scores
    function getMaskState(luxPct, noxPct) {
      const diff = Math.abs(luxPct - noxPct);
      
      if (diff < 5) {
        return { class: 'active', status: 'â—‡ ANALYZING PATTERNS...' };
      } else if (diff < 15) {
        if (luxPct > noxPct) {
          return { class: 'leaning-lux', status: 'â—‡ ALIGNMENT OBSERVED...' };
        } else {
          return { class: 'leaning-nox', status: 'â—‡ DEVIATION OBSERVED...' };
        }
      } else {
        if (luxPct > noxPct) {
          return { class: 'contaminating-lux', status: 'â—‡ VIRTUE TRACED...' };
        } else {
          return { class: 'contaminating-nox', status: 'â—‡ CORRUPTION TRACED...' };
        }
      }
    }

    // Render result
    function renderResult() {
      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const verdict = luxPct >= noxPct ? "LUX" : "NOX";
      
      // Play verdict reveal sound
      if (verdict === "LUX") {
        audio.playLuxReveal();
      } else {
        audio.playNoxReveal();
      }

      const interfaceBody = document.getElementById('interfaceBody');
      interfaceBody.innerHTML = `
        <div class="interfaceState fadeIn">
          <div class="stateIcon verdictIcon ${verdict.toLowerCase()}">â—†</div>
          <div class="stateTitle">
            <span class="${verdict === 'LUX' ? 'luxLabel' : 'noxLabel'}">
              ${verdict} STATE CONFIRMED
            </span>
          </div>
          <div class="stateDesc">
            ${verdict === "LUX"
              ? "Neural patterns indicate virtuous alignment. Subject classified as LUX individual."
              : "Corruption detected in decision matrix. Subject reclassified as NOX individual."}
          </div>

          <div class="dataDivider"></div>

          <div class="verdictPanel">
            <div class="verdictVisual">
              <div class="maskDisplay">
                <svg class="maskSvg ${verdict.toLowerCase()}" viewBox="0 0 200 280" xmlns="http://www.w3.org/2000/svg">
                  <!-- Simple smooth mask outline -->
                  <ellipse cx="100" cy="140" rx="70" ry="90" stroke="currentColor" stroke-width="2" opacity="0.5"/>
                  
                  <!-- Main mask fill -->
                  <ellipse cx="100" cy="140" rx="68" ry="88"/>
                  
                  <!-- Simple oval eyes -->
                  <ellipse cx="75" cy="125" rx="10" ry="15" fill="${verdict === 'LUX' ? '#000000' : '#ffffff'}" opacity="0.6"/>
                  <ellipse cx="125" cy="125" rx="10" ry="15" fill="${verdict === 'LUX' ? '#000000' : '#ffffff'}" opacity="0.6"/>
                  
                  <!-- Simple smile curve -->
                  <path d="M 70 165 Q 100 175 130 165" stroke="${verdict === 'LUX' ? '#000000' : '#ffffff'}" stroke-width="2" fill="none" opacity="0.5"/>
                </svg>
              </div>
            </div>

            <div class="verdictHeader">
              <span>â—ˆ FINAL CLASSIFICATION REPORT</span>
            </div>

            <!-- ALIGNMENT PERCENTAGES -->
            <div class="alignmentDisplay" style="margin-bottom: 30px;">
              <div class="alignmentTitle" style="text-align: center; font-size: 11px; letter-spacing: 2px; color: var(--text-dim); margin-bottom: 20px; font-weight: 700;">
                ALIGNMENT METRICS
              </div>
              <div class="balanceBars">
                <div class="balanceBar">
                  <div class="balanceValue lux">${luxPct}%</div>
                  <div class="balanceLabel luxLabel">LUX VIRTUOUS</div>
                  <div style="margin-top: 10px; height: 6px; background: rgba(0, 168, 255, 0.2); border-radius: 3px; overflow: hidden;">
                    <div style="height: 100%; width: ${luxPct}%; background: var(--lux); box-shadow: 0 0 10px var(--lux-glow); transition: width 0.5s ease;"></div>
                  </div>
                </div>
                <div class="balanceBar">
                  <div class="balanceValue nox">${noxPct}%</div>
                  <div class="balanceLabel noxLabel">NOX CORRUPTION</div>
                  <div style="margin-top: 10px; height: 6px; background: rgba(255, 0, 64, 0.2); border-radius: 3px; overflow: hidden;">
                    <div style="height: 100%; width: ${noxPct}%; background: var(--nox); box-shadow: 0 0 10px var(--nox-glow); transition: width 0.5s ease;"></div>
                  </div>
                </div>
              </div>
            </div>

            <div class="verdictData">
              <div class="verdictRow">
                <span>System:</span>
                <span>VEIL - Virtue Evaluation, Identity Layer</span>
              </div>
              <div class="verdictRow">
                <span>Status:</span>
                <span>INK Exposure Contained Â· Emotion Suppression Active</span>
              </div>
              <div class="verdictRow">
                <span>Analysis:</span>
                <span>Complete - Subject Classified as ${verdict === "LUX" ? "VIRTUOUS" : "CORRUPTED"}</span>
              </div>
              <div class="verdictRow highlight">
                <span>Classification:</span>
                <span class="${verdict === 'LUX' ? 'luxLabel' : 'noxLabel'}">
                  ${verdict === "LUX" ? "â—† LUX STATE READY" : "â—† NOX STATE LOCKED"}
                </span>
              </div>
            </div>

            <div class="verdictActions">
              <button class="cyberBtn primary" id="downloadImage">
                <span>DOWNLOAD IMAGE</span>
                <span class="btnArrow">ðŸ“¸</span>
              </button>
              <button class="cyberBtn secondary" id="resetResult">
                <span>RUN NEW ANALYSIS</span>
                <span class="btnArrow">â†’</span>
              </button>
              <button class="cyberBtn secondary" id="downloadReport">
                <span>DOWNLOAD REPORT</span>
                <span class="btnArrow">â†“</span>
              </button>
            </div>
          </div>
        </div>
      `;

      document.getElementById('downloadImage').addEventListener('click', downloadImage);
      document.getElementById('downloadImage').addEventListener('mouseenter', () => audio.playHover());
      document.getElementById('resetResult').addEventListener('click', resetAll);
      document.getElementById('resetResult').addEventListener('mouseenter', () => audio.playHover());
      document.getElementById('downloadReport').addEventListener('click', downloadReport);
      document.getElementById('downloadReport').addEventListener('mouseenter', () => audio.playHover());
    }

    // Actions
    function startSystem() {
      audio.playClick();
      state = {
        started: true,
        booted: false,
        idx: 0,
        luxScore: 1,
        noxScore: 1,
        answers: {},
        lastVerdict: null,
        sliderVal: 50,
        textVal: "",
      };
      updateUI();
    }

    function resetAll() {
      audio.playClick();
      state = {
        started: false,
        booted: false,
        idx: 0,
        luxScore: 1,
        noxScore: 1,
        answers: {},
        lastVerdict: null,
        sliderVal: 50,
        textVal: "",
      };
      updateUI();
    }

    function submitSingle(q, choice) {
      audio.playSubmit();
      state.answers[q.id] = choice.id;
      state.luxScore += choice.lux || 0;
      state.noxScore += choice.nox || 0;
      state.idx++;
      updateUI();
    }

    function submitSlider(q) {
      audio.playSubmit();
      const v = Number(state.sliderVal);
      const luxGain = Math.round(((v - 50) / 50) * q.slider.luxAtMax);
      const noxGain = Math.round(((50 - v) / 50) * q.slider.noxAtMin);

      state.answers[q.id] = v;
      state.luxScore += clamp(luxGain, 0, 3);
      state.noxScore += clamp(noxGain, 0, 3);
      state.idx++;
      state.sliderVal = 50; // Reset slider to center for next question
      updateUI();
    }

    function submitText(q) {
      audio.playSubmit();
      const text = (state.textVal || "").trim();
      const sig = inferTextSignal(text || "control");

      state.answers[q.id] = text || "";
      state.luxScore += sig.lux;
      state.noxScore += sig.nox;
      state.idx++;
      state.textVal = "";
      updateUI();
    }

    async function copyReadout() {
      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const verdict = luxPct >= noxPct ? "LUX" : "NOX";
      const payload = { luxPct, noxPct, answers: state.answers, verdict };
      const str = JSON.stringify(payload, null, 2);
      
      try {
        await navigator.clipboard.writeText(str);
        audio.playClick();
        alert("Copied.");
      } catch {
        audio.playError();
        alert("Clipboard blocked. Copy manually:\n\n" + str);
      }
    }

    function downloadReport() {
      audio.playClick();
      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const verdict = luxPct >= noxPct ? "LUX" : "NOX";
      const timestamp = new Date().toISOString();
      
      const report = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    VEIL ASSESSMENT REPORT
         Virtue Evaluation, Identity Layer - Classification
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SYSTEM:           VEIL Neural Interface
STATUS:           INK Exposure Contained Â· Emotion Suppression Active
TIMESTAMP:        ${timestamp}
ANALYSIS:         Complete - Subject Classified

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                      FINAL CLASSIFICATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VERDICT:          ${verdict} STATE ${verdict === "LUX" ? "READY" : "LOCKED"}
CLASSIFICATION:   ${verdict === "LUX" ? "VIRTUOUS INDIVIDUAL" : "CORRUPTED INDIVIDUAL"}

ALIGNMENT METRICS:
  LUX Alignment:   ${luxPct}%
  NOX Corruption:  ${noxPct}%

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                      ANALYSIS SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

${verdict === "LUX" 
  ? "Neural patterns indicate virtuous alignment. Subject demonstrates\nconsistent moral reasoning and prosocial decision-making patterns.\nClassified as LUX individual - virtuous state ready for integration."
  : "Corruption detected in decision matrix. Subject exhibits patterns\nof self-interest prioritization and moral compromise. Subject\nreclassified as NOX individual - corrupted state locked."}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    RESPONSE BREAKDOWN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total Questions:  ${QUESTIONS.length}
Responses:        ${Object.keys(state.answers).length}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This report is generated by VEIL (Virtue Evaluation, Identity Layer)
an autonomous moral classification system.

Report ID: VEIL-${Date.now()}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`.trim();

      const blob = new Blob([report], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `VEIL_Report_${verdict}_${Date.now()}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    async function downloadImage() {
      audio.playClick();
      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const verdict = luxPct >= noxPct ? "LUX" : "NOX";
      
      // Create a canvas to draw the result image
      const canvas = document.createElement('canvas');
      canvas.width = 1080;
      canvas.height = 1080;
      const ctx = canvas.getContext('2d');
      
      // Background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, 1080, 1080);
      
      // Grid pattern
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 1080; i += 50) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, 1080);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(1080, i);
        ctx.stroke();
      }
      
      // VEIL title
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 80px "Orbitron", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('VEIL', 540, 120);
      
      ctx.font = '20px "Orbitron", monospace';
      ctx.fillStyle = '#999999';
      ctx.fillText('VIRTUE EVALUATION, IDENTITY LAYER', 540, 160);
      
      // Verdict
      ctx.font = 'bold 100px "Orbitron", monospace';
      ctx.fillStyle = verdict === 'LUX' ? '#00a8ff' : '#ff0040';
      ctx.fillText(verdict, 540, 280);
      
      ctx.font = 'bold 40px "Orbitron", monospace';
      ctx.fillText(verdict === 'LUX' ? 'VIRTUOUS' : 'CORRUPTED', 540, 340);
      
      // Mask
      const maskSize = 400;
      const maskX = 540;
      const maskY = 600;
      
      ctx.save();
      ctx.translate(maskX, maskY);
      
      // Mask outline
      ctx.strokeStyle = verdict === 'LUX' ? '#00a8ff' : '#ff0040';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(0, 0, maskSize * 0.35, maskSize * 0.45, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Mask fill
      ctx.fillStyle = verdict === 'LUX' ? '#ffffff' : '#000000';
      ctx.fill();
      
      // Eyes
      ctx.fillStyle = verdict === 'LUX' ? '#000000' : '#ffffff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.ellipse(-50, -20, 15, 20, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(50, -20, 15, 20, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Mouth
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = verdict === 'LUX' ? '#000000' : '#ffffff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-40, 40);
      ctx.quadraticCurveTo(0, 55, 40, 40);
      ctx.stroke();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // Footer
      ctx.fillStyle = '#999999';
      ctx.font = '24px "Orbitron", monospace';
      ctx.fillText('Classification: ' + (verdict === 'LUX' ? 'LUX STATE READY' : 'NOX STATE LOCKED'), 540, 920);
      
      ctx.font = '18px "Orbitron", monospace';
      ctx.fillText('LUX: ' + luxPct + '%  |  NOX: ' + noxPct + '%', 540, 960);
      
      ctx.font = 'bold 20px "Orbitron", monospace';
      ctx.fillStyle = '#666666';
      ctx.fillText('luxornox.com', 540, 1040);
      
      // Download
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `VEIL_${verdict}_Result.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    // Initialize
    document.getElementById('resetBtn').addEventListener('click', resetAll);
    document.getElementById('resetBtn').addEventListener('mouseenter', () => audio.playHover());
    
    updateUI();
  </script>
</body>
</html>
